#ifndef CowArray_hpp
#define CowArray_hpp

#include <cstdlib>
#include <array>
#include <vector>




namespace Cow
{
    class Array;
    class HeapAllocation;
    class RegionIterator;


    /**
    A class to manage large allocations on the heap using RAII standard.
    */
    class HeapAllocation
    {
    public:

        /**
        Create a null allocation.
        */
        HeapAllocation();

        /**
        Allocate a heap block of the given size. Bytes are not zero-initialized.
        */
        HeapAllocation (std::size_t numberOfBytes);

        /**
        Construct this memory block from a deep copy of another one.
        */
        HeapAllocation (const HeapAllocation& other);

        /**
        Move constructor.
        */
        HeapAllocation (HeapAllocation&& other);

        /**
        Destructor.
        */
        ~HeapAllocation();

        /**
        Assign this block the contents of another (deep copy).
        */
        HeapAllocation& operator= (const HeapAllocation& other);

        /**
        Return the number of bytes in use.
        */
        std::size_t size();

        template <class T> T& getElement (std::size_t index)
        {
            return static_cast<T*>(allocation)[index];
        }

        template <class T> const T& getElement (std::size_t index) const
        {
            return static_cast<T*>(allocation)[index];
        }

        template <class T> T* begin() { return static_cast<T*>(allocation); }
        template <class T> T* end() { return static_cast<T*>(allocation) + numberOfBytes / sizeof(T); }
        template <class T> const T* begin() const { return static_cast<T*>(allocation); }
        template <class T> const T* end() const { return static_cast<T*>(allocation) + numberOfBytes / sizeof(T); }

    private:
        void* allocation;
        std::size_t numberOfBytes;
    };


    /**
    A type to represent the shape of an array or region.
    */
    using Shape = std::array<int, 5>;


    /**
    A type to represent a multi-dimensional index (i, j, k, m, n).
    */
    using Index = std::array<int, 5>;


    /**
    A class that represents a relative range along a single array axis.
    */
    class Range
    {
    public:
        Range (int index);
        Range (int lower, int upper);
        Range (const char*);
        int absoluteLower (int size);
        int absoluteUpper (int size);
        int absoluteLength (int size);
    private:
        const int lower;
        const int upper;
    };


    /**
    A class that represents a relative or absolute region within an array. If
    any component of upper is either zero or negative, then that value
    indicates a distance from the end of the array, and the region is called
    'relative'. An 'absolute' region is generated by providing a shape object
    to the absolute() method. By default each axis covers the range [0:0:1],
    which denotes the entire extent of the axis (note there is no empty
    range).
    */
    class Region
    {
    public:
        Region();
        bool isRelative();
        Region absolute (Shape shape);
        Index lower;
        Index upper;
        Index stride;
    };


    /**
    A multidimensional array class, hard-coded to accommodate up to 5 axes.
    */
    class Array
    {
    public:
        Array();
        Array (int n1);
        Array (int n1, int n2);
        Array (int n1, int n2, int n3);
        Array (int n1, int n2, int n3, int n4);
        Array (int n1, int n2, int n3, int n4, int n5);

        /**
        Copy constructor.
        */
        Array (const Array& other);

        /**
        Move constructor.
        */
        Array (Array&& other);

        /**
        Assignment operator.
        */
        Array& operator= (const Array& other);

        /**
        Set the memory layout to either 'C' or 'F' (C or Fortran) type
        ordering. With 'C', the last index is contiguous in memory, while with
        'F' it is the first index that is contiguous. This function does not
        move any data in the internal buffer, so if the array is already
        populated, then its contents will appear transposed in any subsequent
        indexing.
        */
        void setOrdering (char orderingMode);

        /**
        Return the total number of doubles in this array.
        */
        int size() const;

        /**
        Return the Array's shape as a 5-component array.
        */
        Shape shape() const;

        /**
        Return the memory layout type, 'C' or 'F'.
        */
        char getOrdering() const;

        /**
        Return the shape of this array as a vector, whose length is the number
        of axes that have size greater than 1.
        */
        std::vector<int> getShapeVector() const;

        /**
        Return a new array that is the transpose of this one,

        A.transpose() (i, j, k, m, n) == A (n, m, k, j, i).

        The returned array has same memory layout type as this.
        */
        Array transpose() const;

        /** Retrieve a value by linear index */
        double& operator[] (int index);

        /** Retrieve a const value by linear index */
        const double& operator[] (int index) const;

        double& operator() (int i);
        double& operator() (int i, int j);
        double& operator() (int i, int j, int k);
        double& operator() (int i, int j, int k, int m);
        double& operator() (int i, int j, int k, int m, int n);

        const double& operator() (int i) const;
        const double& operator() (int i, int j) const;
        const double& operator() (int i, int j, int k) const;
        const double& operator() (int i, int j, int k, int m) const;
        const double& operator() (int i, int j, int k, int m, int n) const;

        Array extract (Range is) const;
        Array extract (Range is, Range js) const;
        Array extract (Range is, Range js, Range ks) const;
        Array extract (Range is, Range js, Range ks, Range ms) const;
        Array extract (Range is, Range js, Range ks, Range ms, Range ns) const;

        void insert (const Array& A, Range is);
        void insert (const Array& A, Range is, Range js);
        void insert (const Array& A, Range is, Range js, Range ks);
        void insert (const Array& A, Range is, Range js, Range ks, Range ms);
        void insert (const Array& A, Range is, Range js, Range ks, Range ms, Range ns);


        class Iterator
        {
        public:
            Iterator (Array& A, Region& R, bool isEnd=false);
            operator double*() const;
            double* operator++ ();
            bool operator== (const Iterator& other) const;
        private:
            double* getAddress() const;
            Array& A;
            Region R;
            Index currentIndex;
            double* sentinal;
        };


        class RangeExpression
        {
        public:
            RangeExpression (Array& A, Region& R);
            Iterator begin();
            Iterator end();
        private:
            Array& A;
            Region R;
        };

        double* begin() { return memory.begin<double>(); }
        double* end() { return memory.end<double>(); }
        RangeExpression iterate (Region R);


    private:
        /** @internal */
        static void copyRange (Array& dst, const Array& src,
            Range is, Range js, Range ks, Range ms, Range ns,
            char mode);

        char ordering;
        int n1, n2, n3, n4, n5;
        HeapAllocation memory;
    };
};

#endif